/*
__/\\\________/\\\____/\\\\\\\\\______/\\\\\\\\\\\\\_________/\\\\\\\\\_
__\/\\\_______\/\\\__/\\\///////\\\___\/\\\/////////\\\____/\\\////////__
 __\//\\\______/\\\__\/\\\_____\/\\\___\/\\\_______\/\\\__/\\\/___________
  ___\//\\\____/\\\___\/\\\\\\\\\\\/____\/\\\\\\\\\\\\\/__/\\\_____________
   ____\//\\\__/\\\____\/\\\//////\\\____\/\\\/////////___\/\\\_____________
    _____\//\\\/\\\_____\/\\\____\//\\\___\/\\\____________\//\\\____________
     ______\//\\\\\______\/\\\_____\//\\\__\/\\\_____________\///\\\__________
      _______\//\\\_______\/\\\______\//\\\_\/\\\_______________\////\\\\\\\\\_
       ________\///________\///________\///__\///___________________\/////////__


Non-intrusively binds code and provides access in form of asynchronous remote
procedure calls (RPC).
Author: Dr. Burkhard C. Heisen (https://github.com/bheisen/vrpc)


Licensed under the MIT License <http://opensource.org/licenses/MIT>.
Copyright (c) 2018 - 2021 Dr. Burkhard C. Heisen <burkhard.heisen@heisenware.com>.

Permission is hereby  granted, free of charge, to any  person obtaining a copy
of this software and associated  documentation files (the "Software"), to deal
in the Software  without restriction, including without  limitation the rights
to  use, copy,  modify, merge,  publish, distribute,  sublicense, and/or  sell
copies  of  the Software,  and  to  permit persons  to  whom  the Software  is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE  IS PROVIDED "AS  IS", WITHOUT WARRANTY  OF ANY KIND,  EXPRESS OR
IMPLIED,  INCLUDING BUT  NOT  LIMITED TO  THE  WARRANTIES OF  MERCHANTABILITY,
FITNESS FOR  A PARTICULAR PURPOSE AND  NONINFRINGEMENT. IN NO EVENT  SHALL THE
AUTHORS  OR COPYRIGHT  HOLDERS  BE  LIABLE FOR  ANY  CLAIM,  DAMAGES OR  OTHER
LIABILITY, WHETHER IN AN ACTION OF  CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE  OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
*/

const os = require('os')
const crypto = require('crypto')
const mqtt = require('mqtt')
const EventEmitter = require('events')

/**
 * Client capable of creating proxy objects and remotely calling
 * functions as provided through one or more (distributed) agents.
 *
 * @extends EventEmitter
 */
class VrpcRemote extends EventEmitter {
  /**
   * Constructs a remote client, able to communicate with any distributed agents
   *
   * NOTE: Each instance creates its own physical connection to the broker.
   *
   * @constructor
   * @param {Object} options
   * @param {String} options.token Access token as generated by: https://app.vrpc.io
   * @param {String} options.username MQTT username (if no token is used)
   * @param {String} options.password MQTT password (if no token is provided)
   * @param {String} options.domain Sets default domain
   * @param {String} [options.agent="*"] Sets default agent
   * @param {String} [options.broker="mqtts://vrpc.io:8883"] Broker url in form: `<scheme>://<host>:<port>`
   * @param {Number} [options.timeout=6000] Maximum time in ms to wait for a RPC answer
   * @param {Object} [options.log=console] Log object (must support debug, info, warn, and error level)
   * @param {String} [options.bestEffort=false] If true, message will be sent with best effort, i.e. no caching if offline
   * @example
   * const client = new VrpcRemote({
   *   domain: 'public.vrpc',
   *   broker: 'mqtt://vrpc.io'
   * })
   */
  constructor ({
    token,
    username,
    password,
    domain,
    agent = '*',
    broker = 'mqtts://vrpc.io:8883',
    timeout = 6 * 1000,
    log = 'console',
    bestEffort = false
  } = {}) {
    super()
    // domain sanity check
    if (!domain) throw new Error('The domain must be specified')
    if (domain.match(/[+/#*]/)) {
      throw new Error('The domain must NOT contain any of those characters: "+", "/", "#", "*"')
    }
    // agent sanity check
    if (agent.match(/[+/#]/)) {
      throw new Error('The agent must NOT contain any of those characters: "+", "/", "#"')
    }
    this._token = token
    this._username = username
    this._password = password
    this._agent = agent
    this._domain = domain
    this._broker = broker
    this._timeout = timeout
    this._qos = this._qos = bestEffort ? 0 : 1

    this._instance = crypto.randomBytes(2).toString('hex')
    this._mqttClientId = this._createMqttClientId()
    this._vrpcClientId = this._createVrpcClientId()
    this._domains = {}
    this._eventEmitter = new EventEmitter()
    this._invokeId = 0
    this._client = null
    this._cachedSubscriptions = new Map()
    if (log === 'console') {
      this._log = console
      this._log.debug = () => {}
    } else {
      this._log = log
    }
  }

  /**
   * Actually connects to the MQTT broker.
   *
   * @emits connected
   * @returns {Promise} Resolves once connected within [timeout], rejects otherwise
   * @example
   * try {
   *   await client.connect()
   * } catch (err) {
   *   console.error(`Could not connect because: ${err.message}`)
   * }
   */
  async connect () {
    if (this._client && this._client.connected) return
    let username = this._username
    let password = this._password
    if (this._token) {
      username = '__token__'
      password = this._token
    }
    const options = {
      username,
      password,
      clean: true,
      keepalive: 30,
      clientId: this._mqttClientId,
      rejectUnauthorized: false,
      will: {
        topic: `${this._vrpcClientId}/__clientInfo__`,
        payload: JSON.stringify({ status: 'offline' })
      }
    }
    if (username === undefined) delete options.username
    if (password === undefined) delete options.password
    this._client = mqtt.connect(this._broker, options)

    this._client.on('error', (err) => {
      this.emit('error', err)
    })

    this._client.stream.on('error', (err) => {
      this.emit('error', err)
    })

    this.on('error', (err) => {
      this._log.debug(`Encountered MQTT error: ${err.message}`)
    })

    this._client.on('connect', () => {
      // This will give us an overview of all remotely available classes
      const agent = this._agent === '*' ? '+' : this._agent
      // Agent info
      this._mqttSubscribe(`${this._domain}/${agent}/__agentInfo__`)
      // Class info
      this._mqttSubscribe(`${this._domain}/${agent}/+/__classInfo__`)
      // RPC responses
      this._mqttSubscribe(this._vrpcClientId)
      this.emit('connect')
    })

    this._client.on('message', (topic, message) => {
      if (message.length === 0) return
      const tokens = topic.split('/')
      const [domain, agent, klass, instance] = tokens
      // AgentInfo message
      if (klass === '__agentInfo__') {
        const { status, hostname, version } = JSON.parse(message.toString())
        this._createIfNotExist(domain, agent)
        this._domains[domain].agents[agent].status = status
        this._domains[domain].agents[agent].hostname = hostname
        this._domains[domain].agents[agent].version = version
        this.emit('agent', { domain, agent, status, hostname, version })
      // ClassInfo message
      } else if (instance === '__classInfo__') {
        // Json properties: { className, instances, memberFunctions, staticFunctions }
        const json = JSON.parse(message.toString())
        this._createIfNotExist(domain, agent)
        const oldClassInfo = this._domains[domain].agents[agent].classes[klass]
        const newInstances = json.instances || []
        const oldInstances = oldClassInfo ? oldClassInfo.instances : []
        const removed = oldInstances.filter(x => !newInstances.includes(x))
        const added = newInstances.filter(x => !oldInstances.includes(x))
        this._domains[domain].agents[agent].classes[klass] = json
        const {
          className,
          instances,
          memberFunctions,
          staticFunctions,
          meta
        } = json
        if (removed.length !== 0) this.emit('instanceGone', removed, { domain, agent, className })
        if (added.length !== 0) this.emit('instanceNew', added, { domain, agent, className })
        this.emit(
          'class',
          {
            domain,
            agent,
            className,
            instances,
            memberFunctions,
            staticFunctions,
            meta
          }
        )
      // RPC message
      } else {
        const { id, data } = JSON.parse(message.toString())
        this._eventEmitter.emit(id, data)
      }
    })
    await new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error(`Connection trial timed out (> ${this._timeout} ms)`))
      }, this._timeout)
      this.once('connect', () => {
        clearTimeout(timer)
        resolve()
      })
    })
  }

  async connected () {
    this._log.warn('connected(): This API usage will be deprecated, use "connect()" instead')
    return this.connect()
  }

  /**
   * Creates a new remote instance and provides a proxy to it.
   *
   * Remote instances can be "named" or "anonymous". Named instances are
   * shareable and re-attachable across clients as long as they are not
   * explicitly deleted. Life-cycle changes of named instances are available
   * under the `class`, `instanceNew`, and `instanceGone` events. A named
   * instance is created when specifying the `instance` option.
   *
   * When the `instance` option is not provided, the created proxy is the only
   * object capable of issuing remote function calls. The remote instance stays
   * invisible to other clients.
   *
   * **NOTE** When creating a named instance that already exists, the new proxy will
   * simply attach to (and not re-create) it - just like `getInstance()` was
   * called.
   *
   * @param {Object} options
   * @param {String} options.className Name of the class which should be
   * instantiated
   * @param {String} [options.instance] Name of the created instance. If not
   * provided an (invisible) id will be generated
   * @param {Array} [options.args] Positional arguments for the constructor call
   * @param {String} [options.agent] Agent name. If not provided class default
   * is used
   * @param {String} [options.domain] Domain name. If not provided class default
   * is used
   * @returns {Promise<Proxy>} Object reflecting a proxy to the original one
   * handled by the agent
   * @example
   * // create anonymous instance
   * const proxy1 = await client.create({
   *   className: 'Foo'
   * })
   * // create named instance
   * const proxy2 = await client.create({
   *   className: 'Foo',
   *   instance: 'myFooInstance'
   * })
   * // create named instance providing three constructor arguments
   * const proxy3 = await client.create({
   *   className: 'Bar',
   *   instance: 'myBarInstance',
   *   args: [42, "second argument", { some: 'option' }]
   * })
   */
  async create ({
    className,
    instance,
    args = [],
    agent = this._agent,
    domain = this._domain
  } = {}) {
    if (agent === '*') throw new Error('Agent must be specified')
    const data = instance ? { _1: instance } : {}
    const offset = instance ? 2 : 1
    args.forEach((value, index) => {
      data[`_${index + offset}`] = value
    })
    const json = {
      context: className,
      method: instance ? '__createNamed__' : '__create__',
      id: `${this._instance}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`,
      sender: `${domain}/${os.hostname()}/${this._instance}`,
      data
    }
    return this._getProxy(domain, agent, className, json)
  }

  /**
   * Get a remotely existing instance.
   *
   * Either provide a string only, then VRPC tries to find the instance using
   * client information, or additionally provide an object with explicit meta
   * data.
   *
   * @param {String} instance The instance to be retrieved
   * @param {Object} [options] Explicitly define domain, agent and class
   * @param {String} options.className Name of the instance's class
   * @param {String} options.agent Agent name. If not provided class default is used
   * @param {String} options.domain Domain name. If not provided class default is used
   * @param {bool} options.noWait If true immediately fail if instance could not be found in local cache
   * @returns {Promise<Proxy>} Proxy object reflecting the remotely existing instance
   */
  async getInstance (instance, options) {
    if (typeof instance === 'string') {
      const {
        domain,
        agent,
        className,
        instance: instanceString
      } = await this._getInstanceData(instance, options)
      return this._createProxy(domain, agent, className, instanceString)
    } else { // deprecate this
      this._log.warn('This API usage will be deprecated, use "getInstance(instance, options)" instead')
      console.trace()
      const fakedOptions = { ...instance }
      const fakedInstance = fakedOptions.instance
      delete fakedOptions.instance
      const {
        domain,
        agent,
        className,
        instance: instanceString
      } = await this._getInstanceData(fakedInstance, fakedOptions)
      return this._createProxy(domain, agent, className, instanceString)
    }
  }

  /**
   * Delete a remotely existing instance
   *
   * Either provide a string only, then VRPC tries to find the instance using
   * client information, or provide an object with explicit meta data.
   *
   * @param {String} instance The instance to be deleted
   * @param {Object} [options] Explicitly define domain, agent and class
   * @param {String} options.className Name of the instance's class
   * @param {String} options.agent Agent name. If not provided class default is used
   * @param {String} options.domain Domain name. If not provided class default is used
   * @returns {Promise<Boolean>} true if successful, false otherwise
   */
  async delete (instance, options) {
    let instanceData = { domain: this._domain, agent: this._agent }
    if (typeof instance === 'string') {
      instanceData = await this._getInstanceData(instance)
      if (options) instanceData = { ...options, ...instanceData }
    } else { // deprecate this
      this._log.warn('This API usage will be deprecated, use "delete(instance, options)" instead')
      instanceData = { ...instanceData, ...instance }
    }
    const { domain, agent, className, instance: instanceString } = instanceData
    const json = {
      context: className,
      method: '__delete__',
      id: `${this._instance}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`,
      sender: `${domain}/${os.hostname()}/${this._instance}`,
      data: { _1: instanceString }
    }
    const topic = `${domain}/${agent}/${className}/__static__/__delete__`
    this._mqttPublish(topic, JSON.stringify(json))
    return this._handleAgentAnswer(json)
  }

  /**
   * Calls a static function on a remote class
   *
   * @param {Object} options
   * @param {String} options.className Name of the static function's class
   * @param {String} options.functionName Name of the static function to be called
   * @param {Array} [options.args] Positional arguments of the static function call
   * @param {String} [options.agent] Agent name. If not provided class default is used
   * @param {String} [options.domain] Domain name. If not provided class default is used
   * @returns {Promise<Any>} Return value of the remotely called function
   */
  async callStatic ({
    className,
    functionName,
    args = [],
    agent = this._agent,
    domain = this._domain
  } = {}) {
    const json = {
      context: className,
      method: functionName,
      id: `${this._instance}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`,
      sender: this._vrpcClientId,
      data: this._packData(className, functionName, ...args)
    }
    const topic = `${domain}/${agent}/${className}/__static__/${functionName}`
    await this._waitUntilClassIsOnline(domain, agent, className)
    this._mqttPublish(topic, JSON.stringify(json))
    return this._handleAgentAnswer(json)
  }

  /**
   * Calls the same function on all instances of a given class and returns an
   * aggregated result.
   *
   * NOTE: When no agent was specified as class default and no agent is
   * specified when calling this function, callAll will act on the requested
   * class across all available agents. The same is true when explicitly using
   * a wildcard (*) as agent value.
   *
   * @param {Object} options
   * @param {String} options.className Name of the static function's class
   * @param {Array} [options.args] Positional arguments of the static function call
   * @param {String} [options.agent] Agent name. If not provided class default is
   * used
   * @param {String} [options.domain] Domain name. If not provided class default is
   * used
   * @returns {Promise<Object[]>} An array of objects { id, val, err } carrying
   * the instance id, the return value and potential errors
   */
  async callAll ({
    className,
    functionName,
    args = [],
    agent = this._agent,
    domain = this._domain
  } = {}) {
    const data = { _1: functionName }
    args.forEach((value, index) => (data[`_${index + 2}`] = value))
    const json = {
      context: className,
      method: functionName,
      id: `${this._instance}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`,
      sender: this._vrpcClientId,
      data
    }
    if (agent === '*') {
      const result = []
      const agents = this.getAvailableAgents()
      for (const x of agents) {
        const topic = `${domain}/${x}/${className}/__static__/__callAll__`
        await this._waitUntilClassIsOnline(domain, x, className)
        this._mqttPublish(topic, JSON.stringify(json))
        const tmp = await this._handleAgentAnswer(json)
        result.push(...tmp)
      }
      return result
    }
    const topic = `${domain}/${agent}/${className}/__static__/__callAll__`
    await this._waitUntilClassIsOnline(domain, agent, className)
    this._mqttPublish(topic, JSON.stringify(json))
    return this._handleAgentAnswer(json)
  }

  /**
   * Retrieves all domains, agents, instances, classes, member and static
   * functions potentially available for remote control.
   *
   * @returns {Object} Object with structure:
   * <domain>.agents.<agent>.classes.<className>.instances: []
   * <domain>.agents.<agent>.classes.<className>.memberFunctions: []
   * <domain>.agents.<agent>.classes.<className>.staticFunctions: []
   * <domain>.agents.<agent>.status: 'offline'|'online'
   * <domain>.agents.<agent>.hostname: <hostname>
   */
  getAvailabilities () {
    return this._domains
  }

  /**
   * Retrieves all domains on which agents can be remote controlled
   *
   * @returns {Array} Array of domain names
   */
  getAvailableDomains () {
    return Object.keys(this._domains)
  }

  /**
   * Retrieves all available agents on specific domain.
   *
   * @param {String} [domain] Domain name. If not provided class default is used.
   * @returns {Array} Array of agent names.
   */
  getAvailableAgents (domain = this._domain) {
    return this._domains[domain]
      ? Object.keys(this._domains[domain].agents)
      : []
  }

  /**
   * Retrieves all available classes on specific agent and domain.
   *
   * @param {String} [agent] Agent name. If not provided class default is used.
   * @param {String} [domain] Domain name. If not provided class default is used.
   * @returns {Array} Array of class names.
   */
  getAvailableClasses (agent = this._agent, domain = this._domain) {
    if (agent === '*') throw new Error('Agent must be specified')
    return this._domains[domain]
      ? this._domains[domain].agents[agent]
        ? Object.keys(this._domains[domain].agents[agent].classes)
        : []
      : []
  }

  /**
   * Retrieves all (named) instances on specific class, agent and domain.
   *
   * @param {String} className Class name
   * @param {String} [agent] Agent name. If not provided class default is used
   * @param {String} [domain] Domain name. If not provided class default is used
   * @returns {Array} Array of instance names
   */
  getAvailableInstances (className, agent = this._agent, domain = this._domain) {
    if (agent === '*') throw new Error('Agent must be specified')
    return this._domains[domain]
      ? this._domains[domain].agents[agent]
        ? this._domains[domain].agents[agent].classes[className]
          ? this._domains[domain].agents[agent].classes[className].instances
          : []
        : []
      : []
  }

  /**
   * Retrieves all member functions of specific class, agent and domain.
   *
   * @param {String} className Class name
   * @param {String} [agent] Agent name. If not provided class default is used
   * @param {String} [domain] Domain name. If not provided class default is used
   * @returns {Array} Array of member function names
   */
  getAvailableMemberFunctions (className, agent = this._agent, domain = this._domain) {
    if (agent === '*') throw new Error('Agent must be specified')
    return this._domains[domain]
      ? this._domains[domain].agents[agent]
        ? this._domains[domain].agents[agent].classes[className]
          ? this._domains[domain].agents[agent].classes[className].memberFunctions.map(name => this._stripSignature(name))
          : []
        : []
      : []
  }

  /**
   * Retrieves all static functions of specific class, agent and domain.
   *
   * @param {String} className Class name
   * @param {String} [agent] Agent name. If not provided class default is used
   * @param {String} [domain] Domain name. If not provided class default is used
   * @returns {Array} Array of static function names
   */
  getAvailableStaticFunctions (className, agent = this._agent, domain = this._domain) {
    if (agent === '*') throw new Error('Agent must be specified')
    return this._domains[domain]
      ? this._domains[domain].agents[agent]
        ? this._domains[domain].agents[agent].classes[className]
          ? this._domains[domain].agents[agent].classes[className].staticFunctions.map(name => this._stripSignature(name))
          : []
        : []
      : []
  }

  /**
   * Reconnects to the broker by using a different token
   *
   * @param {String} token Access token as generated by: https://app.vrpc.io
   * @param {Object} [options]
   * @param {String} options.agent Agent name. If not provided class default is used
   * @param {String} options,domain Domain name. If not provided class default is used
   * @returns {Promise} Promise that resolves once re-connected
   */
  async reconnectWithToken (
    token,
    { agent = this._agent, domain = this._domain } = {}
  ) {
    this._token = token
    this._agent = agent
    this._domain = domain
    this._client.end(() => this._init())
    return new Promise(resolve => {
      this._client.once('connect', resolve)
    })
  }

  /**
   * Ends the connection to the broker
   *
   * @returns {Promise} Resolves when ended
   */
  async end () {
    this._mqttPublish(
      `${this._vrpcClientId}/__clientInfo__`,
      JSON.stringify({ status: 'offline' })
    )
    return new Promise(resolve => this._client.end(false, {}, resolve))
  }

  _createMqttClientId () {
    const clientInfo = os.arch() + JSON.stringify(os.cpus()) + os.homedir() +
    os.hostname() + JSON.stringify(os.networkInterfaces()) + os.platform() +
    os.release() + os.totalmem() + os.type()
    // console.log('ClientInfo:', clientInfo)
    const md5 = crypto.createHash('md5').update(clientInfo).digest('hex').substr(0, 13)
    return `vrpcp${this._instance}X${md5}` // 5 + 4 + 1 + 13 = 23 (max clientId)
  }

  _createVrpcClientId () {
    return `${this._domain}/${os.hostname()}/${this._instance}`
  }

  _mqttPublish (topic, message, options) {
    this._client.publish(topic, message, { qos: this._qos, ...options }, (err) => {
      if (err) {
        this._log.warn(`Could not publish MQTT message because: ${err.message}`)
      }
    })
  }

  _mqttSubscribe (topic, options) {
    this._client.subscribe(topic, { qos: this._qos, ...options }, (err, granted) => {
      if (err) {
        this._log.warn(`Could not subscribe to topic: ${topic} because: ${err.message}`)
      } else {
        if (granted.length === 0) {
          this._log.debug(`Already subscribed to: ${topic}`)
        }
      }
    })
  }

  _mqttUnsubscribe (topic, options) {
    this._client.unsubscribe(topic, options, (err) => {
      if (err) {
        this._log.warn(`Could not unsubscribe from topic: ${topic} because: ${err.message}`)
      }
    })
  }

  _createIfNotExist (domain, agent) {
    if (!this._domains[domain]) {
      this._domains[domain] = { agents: {} }
    }
    if (!this._domains[domain].agents[agent]) {
      this._domains[domain].agents[agent] = { classes: {} }
    }
  }

  async _getProxy (domain, agent, className, json) {
    const { method } = json
    const topic = `${domain}/${agent}/${className}/__static__/${method}`
    await this._waitUntilClassIsOnline(domain, agent, className)
    this._mqttPublish(topic, JSON.stringify(json))
    return new Promise((resolve, reject) => {
      const msg = `Proxy creation for class "${className}" on agent "${agent}" and domain "${domain}" timed out (> ${this._timeout} ms)`
      const timer = setTimeout(
        () => {
          this._eventEmitter.removeAllListeners(json.id)
          reject(new Error(msg))
        },
        this._timeout
      )
      this._eventEmitter.once(json.id, data => {
        clearTimeout(timer)
        if (data.e) {
          reject(new Error(data.e))
        } else {
          const proxy = this._createProxy(domain, agent, className, data.r)
          resolve(proxy)
        }
      })
    })
  }

  async _waitUntilClassIsOnline (domain, agent, className) {
    if (this._hasClassOnline(domain, agent, className)) return
    return new Promise((resolve, reject) => {
      let timer = null
      const checkClass = () => {
        if (this._hasClassOnline(domain, agent, className)) {
          if (timer) clearTimeout(timer)
          this.removeListener('class', checkClass)
          resolve()
        }
      }
      timer = setTimeout(() => {
        this.removeListener('class', checkClass)
        reject(new Error(`Proxy creation for class "${className}" on agent "${agent}" and domain "${domain}" timed out (> ${this._timeout} ms)`))
      }, this._timeout)
      this.on('class', checkClass)
    })
  }

  _hasClassOnline (domain, agent, className) {
    return (this._domains[domain] &&
      this._domains[domain].agents[agent] &&
      this._domains[domain].agents[agent].status === 'online' &&
      this._domains[domain].agents[agent].classes[className]
    )
  }

  _createProxy (domain, agent, className, instance) {
    const targetTopic = `${domain}/${agent}/${className}/${instance}`
    const proxyId = crypto.randomBytes(2).toString('hex')
    const proxy = {
      _targetId: instance,
      _proxyId: proxyId
    }
    let functions = this._domains[domain].agents[agent].classes[className].memberFunctions
    // Strip off argument signature
    functions = functions.map(name => {
      const pos = name.indexOf('-')
      if (pos > 0) return name.substring(0, pos)
      return name
    })
    // Remove overloads
    const uniqueFuncs = new Set(functions)
    // Build proxy
    uniqueFuncs.forEach(name => {
      proxy[name] = async (...args) => {
        try {
          const json = {
            context: instance,
            method: name,
            id: `${this._instance}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`,
            sender: this._vrpcClientId,
            data: this._packData(proxyId, name, ...args)
          }
          // Skipping remote call -> handled locally
          if (json.data === null) return
          this._mqttPublish(`${targetTopic}/${name}`, JSON.stringify(json))
          return this._handleAgentAnswer(json)
        } catch (err) {
          throw new Error(`Could not remotely call "${name}" because: ${err.message}`)
        }
      }
    })
    return proxy
  }

  async _handleAgentAnswer ({ id, context, method }) {
    return new Promise((resolve, reject) => {
      const msg = `Function call "${context}::${method}()" timed out (> ${this._timeout} ms)`
      const timer = setTimeout(
        () => {
          this._eventEmitter.removeAllListeners(id)
          reject(new Error(msg))
        },
        this._timeout
      )
      this._eventEmitter.once(id, data => {
        clearTimeout(timer)
        if (data.e) {
          reject(new Error(data.e))
        } else {
          const ret = data.r
          // Handle functions returning a promise
          if (typeof ret === 'string' && ret.substr(0, 5) === '__p__') {
            this._eventEmitter.once(ret, promiseData => {
              if (promiseData.e) reject(new Error(promiseData.e))
              else resolve(promiseData.r)
            })
          } else {
            resolve(ret)
          }
        }
      })
    })
  }

  async _waitForInstance (instance, options = {}) {
    return new Promise((resolve, reject) => {
      const handler = (timer) => (instances, { domain, agent, className }) => {
        if (instances.includes(instance)) {
          if (options.domain && domain !== options.domain) return
          if (options.agent && agent !== options.agent) return
          if (options.className && className !== options.className) return
          clearTimeout(timer)
          this.removeListener('instanceNew', handler)
          resolve({ domain, agent, className, instance })
        }
      }
      const timer = setTimeout(
        () => {
          this.removeListener('instanceNew', handler(timer))
          const msg = `Could not find instance: ${instance} (> ${this._timeout} ms)`
          reject(new Error(msg))
        },
        this._timeout
      )
      this.on('instanceNew', handler(timer))
    })
  }

  _packData (proxyId, functionName, ...args) {
    const data = {}
    let isHandledLocally = false
    args.forEach((value, index) => {
      // Check whether provided argument is a function
      if (this._isFunction(value)) {
        // Check special case of an event emitter registration
        // We test three conditions:
        // 1) functionName must be "on"
        // 2) callback is second argument
        // 3) first argument was string
        if (functionName === 'on' &&
          index === 1 &&
          typeof args[0] === 'string'
        ) {
          const id = this._addEventSubscription(proxyId, args[0], value)
          if (!id) isHandledLocally = true
          data[`_${index + 1}`] = id
        } else if (
          (functionName === 'off' || functionName === 'removeListener') &&
          index === 1 &&
          typeof args[0] === 'string'
        ) {
          const id = this._removeEventSubscription(proxyId, args[0], value)
          if (!id) isHandledLocally = true
          data[`_${index + 1}`] = id
        // Regular function callback
        } else {
          const id = `__f__${proxyId}-${functionName}-${index}-${this._invokeId++ % Number.MAX_SAFE_INTEGER}`
          data[`_${index + 1}`] = id
          this._eventEmitter.once(id, data => {
            const args = Object.keys(data).sort()
              .filter(x => x[0] === '_')
              .map(x => data[x])
            value.apply(null, args) // This is the actual function call
          })
        }
      } else if (this._isEmitter(value)) {
        const { emitter, event } = value
        const id = `__f__${proxyId}-${functionName}-${index}-${event}`
        data[`_${index + 1}`] = id
        this._eventEmitter.on(id, data => {
          const args = Object.keys(data).sort()
            .filter(x => x[0] === '_')
            .map(x => data[x])
          emitter.emit(event, ...args)
        })
      } else {
        data[`_${index + 1}`] = value
      }
    })
    if (isHandledLocally) return null
    return data
  }

  _addEventSubscription (proxyId, event, callback) {
    const id = `__f__${proxyId}-${event}`
    if (this._cachedSubscriptions.has(id)) {
      this._cachedSubscriptions.get(id).on(id, callback)
      return
    }
    const emitter = new EventEmitter()
    emitter.on(id, callback)
    this._cachedSubscriptions.set(id, emitter)
    this._eventEmitter.on(id, (data) => {
      const args = Object.keys(data).sort()
        .filter(x => x[0] === '_')
        .map(x => data[x])
      emitter.emit(id, ...args)
    })
    return id
  }

  _removeEventSubscription (proxyId, event, callback) {
    const id = `__f__${proxyId}-${event}`
    if (this._cachedSubscriptions.has(id)) {
      const emitter = this._cachedSubscriptions.get(id)
      emitter.removeListener(id, callback)
      if (emitter.listenerCount(id) === 0) {
        this._cachedSubscriptions.delete(id)
        this._eventEmitter.removeAllListeners(id)
        return id
      }
    }
  }

  _stripSignature (method) {
    const pos = method.indexOf('-')
    if (pos > 0) return method.substring(0, pos)
    return method
  }

  _isFunction (variable) {
    const getType = {}
    const type = getType.toString.call(variable)
    return variable &&
      (type === '[object Function]' || type === '[object AsyncFunction]')
  }

  _isEmitter (variable) {
    return (
      typeof variable === 'object' &&
      variable.hasOwnProperty('emitter') &&
      variable.hasOwnProperty('event') &&
      typeof variable.emitter === 'object' &&
      typeof variable.emitter.emit === 'function'
    )
  }

  async _getInstanceData (instance, options = {}) {
    const instanceData = this._getInstanceFromCache(instance, options)
    if (!instanceData) {
      if (options.noWait) throw new Error(`Could not find instance: ${instance}`)
      return this._waitForInstance(instance, options)
    }
    return instanceData
  }

  _getInstanceFromCache (instance, options = {}) {
    // loop domains
    for (const domain in this._domains) {
      if (options.domain && domain !== options.domain) continue
      const { agents } = this._domains[domain]
      if (!agents) continue
      for (const agent in agents) {
        if (options.agent && agent !== options.agent) continue
        const { classes, status } = agents[agent]
        if (!classes || status === 'offline') continue
        for (const className in classes) {
          if (options.className && className !== options.className) continue
          const { instances } = classes[className]
          if (!instances) continue
          if (instances.includes(instance)) {
            return { domain, agent, className, instance }
          }
        }
      }
    }
  }
}

/**
 * Event 'agent'
 *
 * This event is fired whenever an agent is added or removed, or whenever
 * an agent changes its status (switches between online or offline).
 *
 * @event VrpcRemote#agent
 * @param {Object} info
 * @param {String} info.domain - Domain name
 * @param {String} info.agent - Agent name
 * @param {String} info.status - Agent status, can be 'offline' or 'online'
 * @param {String} info.hostname - Name of the host running the agent
 * @param {String} info.version - User-defined version of the agent
 */

/**
 * Event 'class'
 *
 * Emitted whenever a class is added or removed, or when instances
 * or functions of this class have changed.
 *
 * @event VrpcRemote#class
 * @param {Object} info
 * @param {String} info.domain - Domain name
 * @param {String} info.agent - Agent name
 * @param {String} info.className - Class name
 * @param {Array.<String>} info.instances - Array of named instances
 * @param {Array.<String>} info.memberFunctions - Array of member functions
 * @param {Array.<String>} info.staticFunctions - Array of static functions
 * @param {MetaData} info.meta - Object associating further information to functions
 */

/**
  * Event 'instanceNew'
  *
  * Emitted whenever a new instance was created.
  *
  * @event VrpcRemote#instanceNew
  *
  * @param {Array.<String>} addedInstances - An array of newly added instances
  * @param {Object} info
  * @param {String} info.domain - Domain name
  * @param {String} info.agent - Agent name
  * @param {String} info.className - Class name
  */

/**
  * Event 'instanceGone'
  *
  * Emitted whenever a new instance was removed.
  *
  * @event VrpcRemote#instanceGone
  *
  * @param {Array.<String>} removedInstances - An array of removed instances
  * @param {Object} info
  * @param {String} info.domain - Domain name
  * @param {String} info.agent - Agent name
  * @param {String} info.className - Class name
  */

/**
 * Event 'connect'
 *
 * Emitted on successful (re)connection (i.e. connack rc=0).
 *
 * @event VrpcRemote#connect
 * @type {Object}
 * @property {Boolean} sessionPresent - A session from a previous connection is already present
*/

/**
 * Event 'reconnect'
 *
 * Emitted when a reconnect starts.
 *
 * @event VrpcRemote#reconnect
*/

/**
 * Event 'close'
 *
 * Emitted after a disconnection.
 *
 * @event VrpcRemote#close
 */

/**
 * Event 'offline'
 *
 * Emitted when the client goes offline.
 *
 * @event VrpcRemote#offline
 */

/**
 * Event 'error'
 *
 * Emitted when the client cannot connect (i.e. connack rc != 0) or when a
 * parsing error occurs. The following TLS errors will be emitted as an error
 * event:
 *
 * - ECONNREFUSED
 * - ECONNRESET
 * - EADDRINUSE
 * - ENOTFOUND
 *
 * @event VrpcRemote#error
 * @type {Object} Error
 */

/**
 * Event 'end'
 *
 * Emitted when mqtt.Client#end() is called. If a callback was passed to
 * mqtt.Client#end(), this event is emitted once the callback returns.
 *
 * @event VrpcRemote#end
 */

module.exports = VrpcRemote
