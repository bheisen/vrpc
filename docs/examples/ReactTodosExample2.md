# Advanced React Todos App

Before you start, make sure you had a look at the `Simple React Todos App`.

If you understood the simple example, you are prepared to go a step further.

We are going to solve the same problem with the same outcome from a user's
perspective, but with an entirely different implementation.

If you take a step back and look at the design of the simple example you
recognize that our backend class reflects something like a *manager* for our
todo items. The *Todos.js* backend-class provides indirect access to the
items through an ID generated by the backend. The individual todo items can not
directly be accessed.

While this is completely fine here, you could think of more
sophisticated cases, where the corresponding thing to the `Todo` item may not
only carry data information but posses much more business logic, inner-state,
and life-cycle. In such a case a *manager* will quickly become tedious and
complex to write as it must wrap all added functionality.

With this in mind we start the example. As before we first create a new
directory, (e.g. `vrpc-react-todos-2`) and run:

```bash
mkdir backend
cd backend
npm init -f -y
npm install vrpc
mkdir src
```

in there.

## Backend

As we want to directly control `Todo` items instead of doing this indirectly through a
*manager*, we write our backend like this:

*src/Todo.js*

```javascript
const EventEmitter = require('events')

class Todo extends EventEmitter {
  constructor (text) {
    super()
    this._data = { text, completed: false }
    setInterval(() => this.toggleCompleted(), 1000)
  }

  getData () {
    return this._data
  }

  toggleCompleted () {
    this._data.completed = !this._data.completed
    this.emit('update', this._data)
  }
}

module.exports = Todo
```

So, what we have done is writing a class whose instances directly reflect
individual `Todo` items. Moreover, have we added a new capability of emitting
an `update` event whenever the item's state is changed (mutated).

That's already it and again we register this class through VRPC to make it
remotely callable:

*index.js*

```javascript
const { VrpcAdapter, VrpcAgent } = require('vrpc')
// Register class "Todos" to be remotely callable
VrpcAdapter.register(require('./src/Todo'))

async function main () {
  try {
    const vrpcAgent = new VrpcAgent({
      agent: 'burkhards-advanced-todos-agent',
      domain: 'public.vrpc'
    })
    await vrpcAgent.serve()
  } catch (err) {
    console.log('VRPC triggered an unexpected error', err)
  }
}

// Start the agent
main()
```

Now, it's interesting to see how it can
be used via [VRPC Live](https://live.vrpc.io). Log in using `public.vrpc`, skip
the token and you will see the `Todo` class under your agent name.

As VRPC can itself manage the life-time of instances (through the injected methods
`create` and `delete`) you can create a `Todo` item by calling `create` with
the arguments:

```javascript
create (a0, 'keep coding') <-
```

This will create a **named** instance of the `Todo` class and pass `'keep coding'`
to the constructor. Think about the `a0` as the ID of your `Todo` item and make
sure to always use unique ones.

Once created, you can call all member functions. When bored, you can also delete
the entire `Todo` item again by calling:

```javascript
delete (a0) <-
```

in the `Todos` class function list.

In the frontend implementation we will make use of this VRPC feature.

## Frontend

Let's quickly setup the project by running the following lines (from within
the root directory):

```bash
npx create-react-app frontend
cd frontend
npm install vrpc
npm install react-vrpc
mkdir -p src/components
```

and modifying the index.js file:

*src/index.js*

```javascript
import React from 'react'
import ReactDOM from 'react-dom'
import App from './components/App'
import * as serviceWorker from './serviceWorker'
import { createVrpcProvider } from 'react-vrpc'

const VrpcProvider = createVrpcProvider({
  domain: 'public.vrpc',
  backends: {
    todos: {
      agent: 'burkhards-advanced-todos-agent',
      className: 'Todo'
    }
  }
})

ReactDOM.render(
  <React.StrictMode>
    <VrpcProvider>
      <App />
    </VrpcProvider>
  </React.StrictMode>,
  document.getElementById('root')
)

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister()
```

Note the difference to the simple example! We are specifying `agent`
and `className` but **NOT** `instance` and/or `args`.

This makes the `todos` backend a *manager* for its own instances.

*src/components/App.js*

```javascript
import React from 'react'
import AddTodo from './AddTodo'
import ShowTodos from './ShowTodos'
import { useBackend } from 'react-vrpc'

function App () {
  const { loading, error } = useBackend('todos')

  if (loading) return 'Loading...'
  if (error) return `Error! ${error.message}`

  return (
    <div>
      <AddTodo />
      <ShowTodos />
    </div>
  )
}

export default App
```

This file is identical to the one in the simple example, so quickly to the next.

*src/components/AddTodo.js*

```javascript
import React from 'react'
import { useBackend } from 'react-vrpc'
function AddTodo () {
  const { backend } = useBackend('todos')

  async function handleSubmit (e) {
    e.preventDefault()
    const { value } = input
    if (!value.trim()) return
    const id = Date.now().toString()
    await backend.create(id, { args: [value] })
    input.value = ''
  }

  let input
  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input ref={node => (input = node)} />
        <button type='submit'>
          Add Todo
        </button>
      </form>
    </div>
  )
}

export default AddTodo
```

Here, you can see the *managing* aspect of the `todos` backend. The two lines:

```javascript
const id = Date.now().toString()
await backend.create(id, { args: [value] })
```

are the important ones. First, we create an `id` (using a timestamp), then
we create a new instance (on the backend!) of a `Todo` class by means of the
`create` method.

Not used here, but just for completeness: there is a `get(id)` and `delete(id)`
method available as well.

When a new instance is created, all `todos` backends will automatically be
updated, so no need to explicitly call `refresh()` here.

*src/components/ShowTodos.js*

```javascript
import React, { useState } from 'react'
import { useBackend } from 'react-vrpc'
import TodoItem from './TodoItemClass'
import Filter from './Filter'

function ShowTodos () {
  const [filter, setFilter] = useState('all')
  const { backend } = useBackend('todos')

  const { ids } = backend
  return (
    <div>
      <ul>
        {ids.map(id => <TodoItem key={id} id={id} filter={filter} />)}
      </ul>
      <Filter
        onClick={setFilter}
        filter={filter}
      />
    </div>
  )
}

export default ShowTodos
```

This component got much shorter, as we moved more logic to the `TodoItem`.
Its main purpose is rendering out the list while applying the correct filter
to it.

Note, how the available `id`s can be retrieved from the `todos` backend:

```javascript
const { ids } = backend
```

and that it does not matter what their values are (as long as they are unique).

*src/components/TodoItem.js*

```javascript
import React, { useEffect, useState, useCallback } from 'react'
import { useBackend } from 'react-vrpc'

function TodoItem ({ id, filter }) {
  const { backend, loading, error } = useBackend('todos', id)
  const [data, setData] = useState({ text: '', completed: false })
  const memoizedUpdate = useCallback(update, [setData, backend])

  useEffect(() => {
    memoizedUpdate()
  }, [memoizedUpdate])

  useEffect(() => {
    if (!backend) return
    const handleUpdate = (data) => setData(data)
    backend.on('update', handleUpdate)
    return () => {
      backend.off('update', handleUpdate).catch(() => {})
    }
  }, [backend])

  async function update () {
    if (!backend) return
    const todoData = await backend.getData()
    setData(todoData)
  }

  async function handleClick () {
    await backend.toggleCompleted()
    await update()
  }

  if (loading) return <li>Loading...</li>
  if (error) return <li>{`Error! ${error.message}`}</li>

  if (filter === 'completed' && !data.completed) return null
  if (filter === 'active' && data.completed) return null

  return (
    <li
      onClick={handleClick}
      style={{ textDecoration: data.completed ? 'line-through' : 'none' }}
    >
      {data.text}
    </li>
  )
}

export default TodoItem
```

This component exactly reflects a single instance of the `Todo` class, you
could say it is its "react twin".

The nicety about this design is that the logic can stay in the lowest hierarchy
component, hence minimizing re-rendering and maximizing performance.

The magic starts with:

```javascript
const { backend, loading, error } = useBackend('todos', id)
```

which provides us with a proxy (`backend`) to a specific `Todo` instance of the
backend.

The rest of the code is obvious besides one feature that is new here:

```javascript
useEffect(() => {
    if (!backend) return
    const handleUpdate = (data) => setData(data)
    backend.on('update', handleUpdate)
    return () => {
      backend.off('update', handleUpdate).catch(() => {})
    }
  }, [backend])
  ```

This effect hook's purpose is to make the UI automatically update whenever the
backend is updated - even when done through a third party.

You can see that it works by simply starting a second UI in a another browser
tab and watching them synchronizing each other nicely, or you manipulate the
backend using [VRPC Live](https://live.vrpc.io).

> **IMPORTANT**
>
> Don't be afraid using events with react-vrpc, it actually is the
> recommended way to synchronize your frontend state with the backend state.
>
> The VRPC API fully implements Node.js' `event` module, just remember to make
> your backend a event emitter by inheriting the EventEmitter class (as is
> best-practice in the node community anyways).
>

For the ones not yet using the amazing hook API of react, there is a
*src/components/TodoItemClass.js* in the example folder...

The last component is boring and did not change from the simple example:

*src/components/Filter.js*

```javascript
import React from 'react'

function Filter ({ onClick, filter }) {
  return (
    <div>
      <span>Show: </span>
      <button
        onClick={() => onClick('all')}
        disabled={filter === 'all'}
        style={{ marginLeft: '4px' }}
      >
        All
      </button>
      <button
        onClick={() => onClick('active')}
        disabled={filter === 'active'}
        style={{ marginLeft: '4px' }}
      >
        Active
      </button>
      <button
        onClick={() => onClick('completed')}
        disabled={filter === 'completed'}
        style={{ marginLeft: '4px' }}
      >
        Completed
      </button>
    </div>
  )
}

export default Filter
```

Voila, there are we again!

Application finished and working, thanks for reading, enjoy playing!
